<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Data.Binary.Conversion.Fast</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--cubical</a> <a id="23" class="Pragma">--safe</a> <a id="30" class="Symbol">#-}</a>

<a id="35" class="Keyword">module</a> <a id="42" href="Data.Binary.Conversion.Fast.html" class="Module">Data.Binary.Conversion.Fast</a> <a id="70" class="Keyword">where</a>

<a id="77" class="Comment">-- This module provides a conversion function from</a>
<a id="128" class="Comment">-- nats which uses built-in functions.</a>
<a id="167" class="Comment">-- It is dramatically faster than the normal conversion</a>
<a id="223" class="Comment">-- even at smaller numbers.</a>

<a id="252" class="Keyword">open</a> <a id="257" class="Keyword">import</a> <a id="264" href="Data.Binary.Definition.html" class="Module">Data.Binary.Definition</a>
<a id="287" class="Keyword">open</a> <a id="292" class="Keyword">import</a> <a id="299" href="Data.Nat.DivMod.html" class="Module">Data.Nat.DivMod</a>
<a id="315" class="Keyword">open</a> <a id="320" class="Keyword">import</a> <a id="327" href="Prelude.html" class="Module">Prelude</a>
<a id="335" class="Keyword">import</a> <a id="342" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="362" class="Symbol">as</a> <a id="365" class="Module">ℕ</a>

<a id="368" class="Comment">-- We build the output by repeatedly halving the input,</a>
<a id="424" class="Comment">-- but we also pass in the number to reduce as we go so that</a>
<a id="485" class="Comment">-- we satisfy the termination checker.</a>
<a id="⟦_⇑⟧"></a><a id="524" href="Data.Binary.Conversion.Fast.html#524" class="Function Operator">⟦_⇑⟧</a> <a id="529" class="Symbol">:</a> <a id="531" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="533" class="Symbol">→</a> <a id="535" href="Data.Bits.html#102" class="Datatype">𝔹</a>
<a id="537" href="Data.Binary.Conversion.Fast.html#524" class="Function Operator">⟦</a> <a id="539" href="Data.Binary.Conversion.Fast.html#539" class="Bound">n</a> <a id="541" href="Data.Binary.Conversion.Fast.html#524" class="Function Operator">⇑⟧</a> <a id="544" class="Symbol">=</a> <a id="546" href="Data.Binary.Conversion.Fast.html#563" class="Function">go</a> <a id="549" href="Data.Binary.Conversion.Fast.html#539" class="Bound">n</a> <a id="551" href="Data.Binary.Conversion.Fast.html#539" class="Bound">n</a>
  <a id="555" class="Keyword">where</a>
  <a id="563" href="Data.Binary.Conversion.Fast.html#563" class="Function">go</a> <a id="566" class="Symbol">:</a> <a id="568" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="570" class="Symbol">→</a> <a id="572" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="574" class="Symbol">→</a> <a id="576" href="Data.Bits.html#102" class="Datatype">𝔹</a>
  <a id="580" href="Data.Binary.Conversion.Fast.html#563" class="Function">go</a> <a id="583" class="Symbol">(</a><a id="584" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="588" href="Data.Binary.Conversion.Fast.html#588" class="Bound">n</a><a id="589" class="Symbol">)</a> <a id="591" class="Symbol">(</a><a id="592" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="596" href="Data.Binary.Conversion.Fast.html#596" class="Bound">w</a><a id="597" class="Symbol">)</a> <a id="599" class="Symbol">=</a>
    <a id="605" href="Strict.html#255" class="Function">let!</a> <a id="610" href="Data.Binary.Conversion.Fast.html#610" class="Bound">rest</a> <a id="615" href="Strict.html#255" class="Function">=!</a> <a id="618" href="Data.Binary.Conversion.Fast.html#563" class="Function">go</a> <a id="621" class="Symbol">(</a><a id="622" href="Data.Binary.Conversion.Fast.html#588" class="Bound">n</a> <a id="624" href="Data.Nat.DivMod.html#230" class="Function Operator">÷</a> <a id="626" class="Number">2</a><a id="627" class="Symbol">)</a> <a id="629" href="Data.Binary.Conversion.Fast.html#596" class="Bound">w</a> <a id="631" href="Strict.html#255" class="Function">in!</a>
    <a id="639" href="Data.Bool.html#532" class="Function Operator">if</a> <a id="642" href="Data.Nat.DivMod.html#316" class="Function">rem</a> <a id="646" href="Data.Binary.Conversion.Fast.html#588" class="Bound">n</a> <a id="648" class="Number">2</a> <a id="650" href="Data.Nat.Properties.html#164" class="Primitive Operator">ℕ.≡ᴮ</a> <a id="655" class="Number">0</a> <a id="657" href="Data.Bool.html#532" class="Function Operator">then</a> <a id="662" href="Data.Bits.html#135" class="InductiveConstructor Operator">1ᵇ</a> <a id="665" href="Data.Binary.Conversion.Fast.html#610" class="Bound">rest</a> <a id="670" href="Data.Bool.html#532" class="Function Operator">else</a> <a id="675" href="Data.Bits.html#155" class="InductiveConstructor Operator">2ᵇ</a> <a id="678" href="Data.Binary.Conversion.Fast.html#610" class="Bound">rest</a>
  <a id="685" href="Data.Binary.Conversion.Fast.html#563" class="Function">go</a> <a id="688" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="696" class="Symbol">_</a>    <a id="701" class="Symbol">=</a> <a id="703" href="Data.Bits.html#123" class="InductiveConstructor">0ᵇ</a>
  <a id="708" href="Data.Binary.Conversion.Fast.html#563" class="Function">go</a> <a id="711" class="Symbol">(</a><a id="712" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="716" class="Symbol">_)</a> <a id="719" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="724" class="Symbol">=</a> <a id="726" href="Data.Bits.html#123" class="InductiveConstructor">0ᵇ</a> <a id="729" class="Comment">-- will not happen</a>

<a id="749" class="Comment">-- Without the added argument to the recursor, the function does not</a>
<a id="818" class="Comment">-- pass the termination checker:</a>
<a id="851" class="Comment">-- {-# TERMINATING #-}</a>
<a id="874" class="Comment">-- ⟦_⇑⟧″ : ℕ → 𝔹</a>
<a id="891" class="Comment">-- ⟦ zero  ⇑⟧″ = 0ᵇ</a>
<a id="911" class="Comment">-- ⟦ suc n ⇑⟧″ =</a>
<a id="928" class="Comment">--   if rem n 2 ℕ.≡ᴮ 0</a>
<a id="951" class="Comment">--   then 1ᵇ ⟦ n ÷ 2 ⇑⟧″</a>
<a id="976" class="Comment">--   else 2ᵇ ⟦ n ÷ 2 ⇑⟧″</a>

<a id="1002" class="Comment">-- The &quot;principled&quot; version (which uses well-founded recursion) is</a>
<a id="1069" class="Comment">-- incredibly slow. (and the following doesn&#39;t even compute, because of</a>
<a id="1141" class="Comment">-- cubical)</a>

<a id="1154" class="Comment">-- open import Data.Nat.WellFounded</a>

<a id="1191" class="Comment">-- ⟦_⇑⟧‴ : ℕ → 𝔹</a>
<a id="1208" class="Comment">-- ⟦ n ⇑⟧‴ = go n (≤-wellFounded n)</a>
<a id="1244" class="Comment">--   where</a>
<a id="1255" class="Comment">--   go : ∀ n → Acc _&lt;_ n → 𝔹</a>
<a id="1285" class="Comment">--   go zero    wf = 0ᵇ</a>
<a id="1309" class="Comment">--   go (suc n) (acc wf) =</a>
<a id="1336" class="Comment">--     if rem n 2 ℕ.≡ᴮ 0</a>
<a id="1361" class="Comment">--     then 1ᵇ go (n ÷ 2) (wf (n ÷ 2) (s≤s (div2≤ n)))</a>
<a id="1416" class="Comment">--     else 2ᵇ go (n ÷ 2) (wf (n ÷ 2) (s≤s (div2≤ n)))</a>
</pre></body></html>