<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Data.Binary.Conversion.Fast</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--cubical</a> <a id="23" class="Pragma">--safe</a> <a id="30" class="Symbol">#-}</a>

<a id="35" class="Keyword">module</a> <a id="42" href="Data.Binary.Conversion.Fast.html" class="Module">Data.Binary.Conversion.Fast</a> <a id="70" class="Keyword">where</a>

<a id="77" class="Comment">-- This module provides a conversion function from</a>
<a id="128" class="Comment">-- nats which uses built-in functions.</a>
<a id="167" class="Comment">-- It is dramatically faster than the normal conversion</a>
<a id="223" class="Comment">-- even at smaller numbers.</a>

<a id="252" class="Keyword">open</a> <a id="257" class="Keyword">import</a> <a id="264" href="Data.Binary.Definition.html" class="Module">Data.Binary.Definition</a>
<a id="287" class="Keyword">open</a> <a id="292" class="Keyword">import</a> <a id="299" href="Data.Nat.DivMod.html" class="Module">Data.Nat.DivMod</a>
<a id="315" class="Keyword">open</a> <a id="320" class="Keyword">import</a> <a id="327" href="Prelude.html" class="Module">Prelude</a>
<a id="335" class="Keyword">import</a> <a id="342" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="362" class="Symbol">as</a> <a id="365" class="Module">ℕ</a>


<a id="toBin-helper"></a><a id="369" href="Data.Binary.Conversion.Fast.html#369" class="Function">toBin-helper</a> <a id="382" class="Symbol">:</a> <a id="384" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="386" class="Symbol">→</a> <a id="388" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="390" class="Symbol">→</a> <a id="392" href="Data.Bits.html#102" class="Datatype">𝔹</a>
<a id="394" href="Data.Binary.Conversion.Fast.html#369" class="Function">toBin-helper</a> <a id="407" class="Symbol">(</a><a id="408" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="412" href="Data.Binary.Conversion.Fast.html#412" class="Bound">n</a><a id="413" class="Symbol">)</a> <a id="415" class="Symbol">(</a><a id="416" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="420" href="Data.Binary.Conversion.Fast.html#420" class="Bound">w</a><a id="421" class="Symbol">)</a> <a id="423" class="Symbol">=</a>
  <a id="427" href="Strict.html#255" class="Function">let!</a> <a id="432" href="Data.Binary.Conversion.Fast.html#432" class="Bound">rest</a> <a id="437" href="Strict.html#255" class="Function">=!</a> <a id="440" href="Data.Binary.Conversion.Fast.html#369" class="Function">toBin-helper</a> <a id="453" class="Symbol">(</a><a id="454" href="Data.Binary.Conversion.Fast.html#412" class="Bound">n</a> <a id="456" href="Data.Nat.DivMod.html#231" class="Function Operator">÷</a> <a id="458" class="Number">2</a><a id="459" class="Symbol">)</a> <a id="461" href="Data.Binary.Conversion.Fast.html#420" class="Bound">w</a> <a id="463" href="Strict.html#255" class="Function">in!</a>
  <a id="469" href="Data.Bool.html#532" class="Function Operator">if</a> <a id="472" href="Data.Nat.DivMod.html#317" class="Function">rem</a> <a id="476" href="Data.Binary.Conversion.Fast.html#412" class="Bound">n</a> <a id="478" class="Number">2</a> <a id="480" href="Data.Nat.Properties.html#164" class="Primitive Operator">ℕ.≡ᴮ</a> <a id="485" class="Number">0</a> <a id="487" href="Data.Bool.html#532" class="Function Operator">then</a> <a id="492" href="Data.Bits.html#135" class="InductiveConstructor Operator">1ᵇ</a> <a id="495" href="Data.Binary.Conversion.Fast.html#432" class="Bound">rest</a> <a id="500" href="Data.Bool.html#532" class="Function Operator">else</a> <a id="505" href="Data.Bits.html#155" class="InductiveConstructor Operator">2ᵇ</a> <a id="508" href="Data.Binary.Conversion.Fast.html#432" class="Bound">rest</a>
<a id="513" href="Data.Binary.Conversion.Fast.html#369" class="Function">toBin-helper</a> <a id="526" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="534" class="Symbol">_</a>    <a id="539" class="Symbol">=</a> <a id="541" href="Data.Bits.html#123" class="InductiveConstructor">0ᵇ</a>
<a id="544" href="Data.Binary.Conversion.Fast.html#369" class="Function">toBin-helper</a> <a id="557" class="Symbol">(</a><a id="558" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="562" class="Symbol">_)</a> <a id="565" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="570" class="Symbol">=</a> <a id="572" href="Data.Bits.html#123" class="InductiveConstructor">0ᵇ</a> <a id="575" class="Comment">-- will not happen</a>


<a id="596" class="Comment">-- We build the output by repeatedly halving the input,</a>
<a id="652" class="Comment">-- but we also pass in the number to reduce as we go so that</a>
<a id="713" class="Comment">-- we satisfy the termination checker.</a>
<a id="⟦_⇑⟧"></a><a id="752" href="Data.Binary.Conversion.Fast.html#752" class="Function Operator">⟦_⇑⟧</a> <a id="757" class="Symbol">:</a> <a id="759" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="761" class="Symbol">→</a> <a id="763" href="Data.Bits.html#102" class="Datatype">𝔹</a>
<a id="765" href="Data.Binary.Conversion.Fast.html#752" class="Function Operator">⟦</a> <a id="767" href="Data.Binary.Conversion.Fast.html#767" class="Bound">n</a> <a id="769" href="Data.Binary.Conversion.Fast.html#752" class="Function Operator">⇑⟧</a> <a id="772" class="Symbol">=</a> <a id="774" href="Data.Binary.Conversion.Fast.html#369" class="Function">toBin-helper</a> <a id="787" href="Data.Binary.Conversion.Fast.html#767" class="Bound">n</a> <a id="789" href="Data.Binary.Conversion.Fast.html#767" class="Bound">n</a>
<a id="791" class="Symbol">{-#</a> <a id="795" class="Keyword">INLINE</a> <a id="802" href="Data.Binary.Conversion.Fast.html#752" class="Function Operator">⟦_⇑⟧</a> <a id="807" class="Symbol">#-}</a>

<a id="812" class="Comment">-- Without the added argument to the recursor, the function does not</a>
<a id="881" class="Comment">-- pass the termination checker:</a>
<a id="914" class="Comment">-- {-# TERMINATING #-}</a>
<a id="937" class="Comment">-- ⟦_⇑⟧″ : ℕ → 𝔹</a>
<a id="954" class="Comment">-- ⟦ zero  ⇑⟧″ = 0ᵇ</a>
<a id="974" class="Comment">-- ⟦ suc n ⇑⟧″ =</a>
<a id="991" class="Comment">--   if rem n 2 ℕ.≡ᴮ 0</a>
<a id="1014" class="Comment">--   then 1ᵇ ⟦ n ÷ 2 ⇑⟧″</a>
<a id="1039" class="Comment">--   else 2ᵇ ⟦ n ÷ 2 ⇑⟧″</a>

<a id="1065" class="Comment">-- The &quot;principled&quot; version (which uses well-founded recursion) is</a>
<a id="1132" class="Comment">-- incredibly slow. (and the following doesn&#39;t even compute, because of</a>
<a id="1204" class="Comment">-- cubical)</a>

<a id="1217" class="Comment">-- open import Data.Nat.WellFounded</a>

<a id="1254" class="Comment">-- ⟦_⇑⟧‴ : ℕ → 𝔹</a>
<a id="1271" class="Comment">-- ⟦ n ⇑⟧‴ = go n (≤-wellFounded n)</a>
<a id="1307" class="Comment">--   where</a>
<a id="1318" class="Comment">--   go : ∀ n → Acc _&lt;_ n → 𝔹</a>
<a id="1348" class="Comment">--   go zero    wf = 0ᵇ</a>
<a id="1372" class="Comment">--   go (suc n) (acc wf) =</a>
<a id="1399" class="Comment">--     if rem n 2 ℕ.≡ᴮ 0</a>
<a id="1424" class="Comment">--     then 1ᵇ go (n ÷ 2) (wf (n ÷ 2) (s≤s (div2≤ n)))</a>
<a id="1479" class="Comment">--     else 2ᵇ go (n ÷ 2) (wf (n ÷ 2) (s≤s (div2≤ n)))</a>
</pre></body></html>