<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Control.Comonad.IntervalHeap</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--no-positivity-check</a> <a id="35" class="Pragma">--no-termination-check</a> <a id="58" class="Symbol">#-}</a>

<a id="63" class="Keyword">open</a> <a id="68" class="Keyword">import</a> <a id="75" href="Algebra.html" class="Module">Algebra</a>
<a id="83" class="Keyword">open</a> <a id="88" class="Keyword">import</a> <a id="95" href="Prelude.html" class="Module">Prelude</a>
<a id="103" class="Keyword">open</a> <a id="108" class="Keyword">import</a> <a id="115" href="Relation.Binary.html" class="Module">Relation.Binary</a>
<a id="131" class="Keyword">open</a> <a id="136" class="Keyword">import</a> <a id="143" href="WellFounded.html" class="Module">WellFounded</a>
<a id="155" class="Keyword">open</a> <a id="160" class="Keyword">import</a> <a id="167" href="Algebra.Monus.html" class="Module">Algebra.Monus</a>
<a id="181" class="Keyword">open</a> <a id="186" class="Keyword">import</a> <a id="193" href="Data.Maybe.html" class="Module">Data.Maybe</a>
<a id="204" class="Keyword">open</a> <a id="209" class="Keyword">import</a> <a id="216" href="Data.List.html" class="Module">Data.List</a> <a id="226" class="Keyword">renaming</a> <a id="235" class="Symbol">(</a><a id="236" href="Data.List.Base.html#1042" class="Function">map</a> <a id="240" class="Symbol">to</a> <a id="243" class="Function">Lmap</a><a id="247" class="Symbol">)</a>

<a id="250" class="Keyword">module</a> <a id="257" href="Control.Comonad.IntervalHeap.html" class="Module">Control.Comonad.IntervalHeap</a> <a id="286" class="Symbol">{</a><a id="287" href="Control.Comonad.IntervalHeap.html#287" class="Bound">s</a><a id="288" class="Symbol">}</a>
  <a id="292" class="Symbol">(</a><a id="293" href="Control.Comonad.IntervalHeap.html#293" class="Bound">mon</a> <a id="297" class="Symbol">:</a> <a id="299" href="Algebra.Monus.html#4805" class="Record">TMAPOM</a> <a id="306" href="Control.Comonad.IntervalHeap.html#287" class="Bound">s</a><a id="307" class="Symbol">)</a>
  <a id="311" class="Symbol">(</a><a id="312" href="Control.Comonad.IntervalHeap.html#312" class="Bound">comon</a> <a id="318" class="Symbol">:</a> <a id="320" href="Algebra.html#10471" class="Record">GradedComonad</a> <a id="334" class="Symbol">(</a><a id="335" href="Algebra.html#2843" class="Function">TMAPOM.monoid</a> <a id="349" href="Control.Comonad.IntervalHeap.html#293" class="Bound">mon</a><a id="352" class="Symbol">)</a> <a id="354" href="Control.Comonad.IntervalHeap.html#287" class="Bound">s</a> <a id="356" href="Control.Comonad.IntervalHeap.html#287" class="Bound">s</a><a id="357" class="Symbol">)</a>
  <a id="361" class="Keyword">where</a>

<a id="368" class="Keyword">open</a> <a id="373" href="Algebra.Monus.html#4805" class="Module">TMAPOM</a> <a id="380" href="Control.Comonad.IntervalHeap.html#293" class="Bound">mon</a>
<a id="384" class="Keyword">open</a> <a id="389" href="Algebra.html#10471" class="Module">GradedComonad</a> <a id="403" href="Control.Comonad.IntervalHeap.html#312" class="Bound">comon</a>

<a id="410" class="Keyword">data</a> <a id="Heap"></a><a id="415" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="420" class="Symbol">(</a><a id="421" href="Control.Comonad.IntervalHeap.html#421" class="Bound">A</a> <a id="423" class="Symbol">:</a> <a id="425" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="430" href="Control.Comonad.IntervalHeap.html#287" class="Bound">s</a><a id="431" class="Symbol">)</a> <a id="433" class="Symbol">:</a> <a id="435" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="440" href="Control.Comonad.IntervalHeap.html#287" class="Bound">s</a> <a id="442" class="Keyword">where</a>
  <a id="Heap._◃_"></a><a id="450" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">_◃_</a> <a id="454" class="Symbol">:</a> <a id="456" class="Symbol">(</a><a id="457" href="Control.Comonad.IntervalHeap.html#457" class="Bound">w</a> <a id="459" class="Symbol">:</a> <a id="461" href="Algebra.html#1401" class="Function">𝑆</a><a id="462" class="Symbol">)</a> <a id="464" class="Symbol">→</a> <a id="466" class="Symbol">(</a><a id="467" href="Control.Comonad.IntervalHeap.html#467" class="Bound">xs</a> <a id="470" class="Symbol">:</a> <a id="472" href="Algebra.html#10587" class="Field">𝐹</a> <a id="474" href="Control.Comonad.IntervalHeap.html#457" class="Bound">w</a> <a id="476" class="Symbol">(</a><a id="477" href="Control.Comonad.IntervalHeap.html#421" class="Bound">A</a> <a id="479" href="Data.Sigma.Base.html#455" class="Function Operator">×</a> <a id="481" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="486" class="Symbol">(</a><a id="487" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="492" href="Control.Comonad.IntervalHeap.html#421" class="Bound">A</a><a id="493" class="Symbol">)))</a> <a id="497" class="Symbol">→</a> <a id="499" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="504" href="Control.Comonad.IntervalHeap.html#421" class="Bound">A</a>

<a id="extend"></a><a id="507" href="Control.Comonad.IntervalHeap.html#507" class="Function">extend</a> <a id="514" class="Symbol">:</a> <a id="516" class="Symbol">(</a><a id="517" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="522" href="Level.html#255" class="Generalizable">A</a> <a id="524" class="Symbol">→</a> <a id="526" href="Level.html#269" class="Generalizable">B</a><a id="527" class="Symbol">)</a> <a id="529" class="Symbol">→</a> <a id="531" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="536" href="Level.html#255" class="Generalizable">A</a> <a id="538" class="Symbol">→</a> <a id="540" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="545" href="Level.html#269" class="Generalizable">B</a>
<a id="547" href="Control.Comonad.IntervalHeap.html#507" class="Function">extend</a> <a id="554" href="Control.Comonad.IntervalHeap.html#554" class="Bound">f</a> <a id="556" class="Symbol">(</a><a id="557" href="Control.Comonad.IntervalHeap.html#557" class="Bound">w</a> <a id="559" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="561" href="Control.Comonad.IntervalHeap.html#561" class="Bound">xs</a><a id="563" class="Symbol">)</a> <a id="565" class="Symbol">=</a> <a id="567" href="Control.Comonad.IntervalHeap.html#557" class="Bound">w</a> <a id="569" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="571" class="Symbol">(</a><a id="572" href="Control.Comonad.IntervalHeap.html#561" class="Bound">xs</a> <a id="575" href="Algebra.html#10696" class="Function">=&gt;&gt;[</a> <a id="580" href="Cubical.Foundations.Id.html#703" class="Function">sym</a> <a id="584" class="Symbol">(</a><a id="585" href="Algebra.html#1537" class="Function">∙ε</a> <a id="588" href="Control.Comonad.IntervalHeap.html#557" class="Bound">w</a><a id="589" class="Symbol">)</a> <a id="591" href="Algebra.html#10696" class="Function">]</a> <a id="593" class="Symbol">(λ</a> <a id="596" href="Control.Comonad.IntervalHeap.html#596" class="Bound">ys</a> <a id="599" class="Symbol">→</a> <a id="601" href="Control.Comonad.IntervalHeap.html#554" class="Bound">f</a> <a id="603" class="Symbol">(</a><a id="604" href="Algebra.html#1444" class="Function">ε</a> <a id="606" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="608" href="Control.Comonad.IntervalHeap.html#596" class="Bound">ys</a><a id="610" class="Symbol">)</a> <a id="612" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="614" href="Control.Comonad.IntervalHeap.html#243" class="Function">Lmap</a> <a id="619" class="Symbol">(</a><a id="620" href="Control.Comonad.IntervalHeap.html#507" class="Function">extend</a> <a id="627" href="Control.Comonad.IntervalHeap.html#554" class="Bound">f</a><a id="628" class="Symbol">)</a> <a id="630" class="Symbol">(</a><a id="631" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="635" class="Symbol">(</a><a id="636" href="Algebra.html#10617" class="Field">extract</a> <a id="644" href="Control.Comonad.IntervalHeap.html#596" class="Bound">ys</a><a id="646" class="Symbol">))))</a>

<a id="652" class="Keyword">module</a> <a id="659" href="Control.Comonad.IntervalHeap.html#659" class="Module">_</a> <a id="661" class="Symbol">(</a><a id="662" href="Control.Comonad.IntervalHeap.html#662" class="Bound">2-monoid</a> <a id="671" class="Symbol">:</a> <a id="673" class="Symbol">∀</a> <a id="675" class="Symbol">{</a><a id="676" href="Control.Comonad.IntervalHeap.html#676" class="Bound">A</a> <a id="678" href="Control.Comonad.IntervalHeap.html#678" class="Bound">B</a> <a id="680" href="Control.Comonad.IntervalHeap.html#680" class="Bound">w</a><a id="681" class="Symbol">}</a> <a id="683" class="Symbol">→</a> <a id="685" href="Algebra.html#10587" class="Field">𝐹</a> <a id="687" href="Control.Comonad.IntervalHeap.html#680" class="Bound">w</a> <a id="689" href="Control.Comonad.IntervalHeap.html#676" class="Bound">A</a> <a id="691" class="Symbol">→</a> <a id="693" href="Algebra.html#10587" class="Field">𝐹</a> <a id="695" href="Control.Comonad.IntervalHeap.html#680" class="Bound">w</a> <a id="697" href="Control.Comonad.IntervalHeap.html#678" class="Bound">B</a> <a id="699" class="Symbol">→</a> <a id="701" href="Algebra.html#10587" class="Field">𝐹</a> <a id="703" href="Control.Comonad.IntervalHeap.html#680" class="Bound">w</a> <a id="705" class="Symbol">(</a><a id="706" href="Control.Comonad.IntervalHeap.html#676" class="Bound">A</a> <a id="708" href="Data.Sigma.Base.html#455" class="Function Operator">×</a> <a id="710" href="Control.Comonad.IntervalHeap.html#678" class="Bound">B</a><a id="711" class="Symbol">))</a> <a id="714" class="Keyword">where</a>
  <a id="722" href="Control.Comonad.IntervalHeap.html#722" class="Function Operator">_∪_</a> <a id="726" class="Symbol">:</a> <a id="728" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="733" href="Level.html#255" class="Generalizable">A</a> <a id="735" class="Symbol">→</a> <a id="737" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="742" href="Level.html#255" class="Generalizable">A</a> <a id="744" class="Symbol">→</a> <a id="746" href="Control.Comonad.IntervalHeap.html#415" class="Datatype">Heap</a> <a id="751" href="Level.html#255" class="Generalizable">A</a>
  <a id="755" class="Symbol">(</a><a id="756" href="Control.Comonad.IntervalHeap.html#756" class="Bound">xw</a> <a id="759" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="761" href="Control.Comonad.IntervalHeap.html#761" class="Bound">xs</a><a id="763" class="Symbol">)</a> <a id="765" href="Control.Comonad.IntervalHeap.html#722" class="Function Operator">∪</a> <a id="767" class="Symbol">(</a><a id="768" href="Control.Comonad.IntervalHeap.html#768" class="Bound">yw</a> <a id="771" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="773" href="Control.Comonad.IntervalHeap.html#773" class="Bound">ys</a><a id="775" class="Symbol">)</a> <a id="777" class="Keyword">with</a> <a id="782" href="Control.Comonad.IntervalHeap.html#756" class="Bound">xw</a> <a id="785" href="Algebra.Monus.html#4294" class="Function Operator">≤|≥</a> <a id="789" href="Control.Comonad.IntervalHeap.html#768" class="Bound">yw</a>
  <a id="794" class="Symbol">...</a> <a id="798" class="Symbol">|</a> <a id="800" href="Data.Sum.html#226" class="InductiveConstructor">inl</a> <a id="804" class="Symbol">(</a><a id="805" href="Control.Comonad.IntervalHeap.html#805" class="Bound">k</a> <a id="807" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="809" href="Control.Comonad.IntervalHeap.html#809" class="Bound">p</a><a id="810" class="Symbol">)</a> <a id="812" class="Symbol">=</a> <a id="814" class="Bound">xw</a> <a id="817" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="819" href="Algebra.html#11447" class="Function">map</a> <a id="823" class="Symbol">(λ</a> <a id="826" class="Symbol">{</a> <a id="828" class="Symbol">(</a><a id="829" href="Control.Comonad.IntervalHeap.html#829" class="Bound">y</a> <a id="831" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="833" class="Symbol">(</a><a id="834" href="Control.Comonad.IntervalHeap.html#834" class="Bound">x</a> <a id="836" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="838" href="Control.Comonad.IntervalHeap.html#838" class="Bound">xs</a><a id="840" class="Symbol">))</a> <a id="843" class="Symbol">→</a> <a id="845" href="Control.Comonad.IntervalHeap.html#834" class="Bound">x</a> <a id="847" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="849" class="Symbol">(</a><a id="850" href="Control.Comonad.IntervalHeap.html#805" class="Bound">k</a> <a id="852" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="854" href="Control.Comonad.IntervalHeap.html#829" class="Bound">y</a><a id="855" class="Symbol">)</a> <a id="857" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="859" href="Control.Comonad.IntervalHeap.html#838" class="Bound">xs</a> <a id="862" class="Symbol">})</a> <a id="865" class="Symbol">(</a><a id="866" href="Control.Comonad.IntervalHeap.html#662" class="Bound">2-monoid</a> <a id="875" class="Symbol">(</a><a id="876" class="Bound">ys</a> <a id="879" href="Algebra.html#10696" class="Function">=&gt;&gt;[</a> <a id="884" href="Control.Comonad.IntervalHeap.html#809" class="Bound">p</a> <a id="886" href="Algebra.html#10696" class="Function">]</a> <a id="888" href="Function.html#533" class="Function">id</a><a id="890" class="Symbol">)</a> <a id="892" class="Bound">xs</a><a id="894" class="Symbol">)</a>
  <a id="898" class="Symbol">...</a> <a id="902" class="Symbol">|</a> <a id="904" href="Data.Sum.html#244" class="InductiveConstructor">inr</a> <a id="908" class="Symbol">(</a><a id="909" href="Control.Comonad.IntervalHeap.html#909" class="Bound">k</a> <a id="911" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="913" href="Control.Comonad.IntervalHeap.html#913" class="Bound">p</a><a id="914" class="Symbol">)</a> <a id="916" class="Symbol">=</a> <a id="918" class="Bound">yw</a> <a id="921" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="923" href="Algebra.html#11447" class="Function">map</a> <a id="927" class="Symbol">(λ</a> <a id="930" class="Symbol">{</a> <a id="932" class="Symbol">(</a><a id="933" href="Control.Comonad.IntervalHeap.html#933" class="Bound">x</a> <a id="935" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="937" class="Symbol">(</a><a id="938" href="Control.Comonad.IntervalHeap.html#938" class="Bound">y</a> <a id="940" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="942" href="Control.Comonad.IntervalHeap.html#942" class="Bound">ys</a><a id="944" class="Symbol">))</a> <a id="947" class="Symbol">→</a> <a id="949" href="Control.Comonad.IntervalHeap.html#938" class="Bound">y</a> <a id="951" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="953" class="Symbol">(</a><a id="954" href="Control.Comonad.IntervalHeap.html#909" class="Bound">k</a> <a id="956" href="Control.Comonad.IntervalHeap.html#450" class="InductiveConstructor Operator">◃</a> <a id="958" href="Control.Comonad.IntervalHeap.html#933" class="Bound">x</a><a id="959" class="Symbol">)</a> <a id="961" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="963" href="Control.Comonad.IntervalHeap.html#942" class="Bound">ys</a> <a id="966" class="Symbol">})</a> <a id="969" class="Symbol">(</a><a id="970" href="Control.Comonad.IntervalHeap.html#662" class="Bound">2-monoid</a> <a id="979" class="Symbol">(</a><a id="980" class="Bound">xs</a> <a id="983" href="Algebra.html#10696" class="Function">=&gt;&gt;[</a> <a id="988" href="Control.Comonad.IntervalHeap.html#913" class="Bound">p</a> <a id="990" href="Algebra.html#10696" class="Function">]</a> <a id="992" href="Function.html#533" class="Function">id</a><a id="994" class="Symbol">)</a> <a id="996" class="Bound">ys</a><a id="998" class="Symbol">)</a>

<a id="1001" class="Comment">-- mutual</a>
<a id="1011" class="Comment">--   record Heap (A : Type a) : Type (s ℓ⊔ a) where</a>
<a id="1063" class="Comment">--     inductive; constructor _◃_</a>
<a id="1097" class="Comment">--     field</a>
<a id="1110" class="Comment">--       hd : A</a>
<a id="1126" class="Comment">--       tl : Next A</a>

<a id="1148" class="Comment">--   record Next {a} (A : Type a) : Type (s ℓ⊔ a) where</a>
<a id="1204" class="Comment">--     coinductive; constructor ⟪_⟫</a>
<a id="1240" class="Comment">--     field next : Span A</a>

<a id="1268" class="Comment">--   data Span {a} (A : Type a) : Type (s ℓ⊔ a) where</a>
<a id="1322" class="Comment">--     [] : Span A</a>
<a id="1341" class="Comment">--     until : (s : 𝑆) → (s≢ε : s ≢ ε) → (xs : Heap A) → Span A</a>
<a id="1405" class="Comment">-- open Heap public</a>
<a id="1425" class="Comment">-- open Next public</a>

<a id="1446" class="Comment">-- State : Type a → Type _</a>
<a id="1473" class="Comment">-- State A = 𝑆 → A × 𝑆</a>

<a id="1497" class="Comment">-- pop′ : (s : 𝑆) → Acc _&lt;_ s → Heap A → A × 𝑆</a>
<a id="1544" class="Comment">-- pop′ s₂ a xs with xs .tl .next</a>
<a id="1578" class="Comment">-- pop′ s₂ a xs | [] = xs .hd , ε</a>
<a id="1612" class="Comment">-- pop′ s₂ a xs | until s₁ s₁≢ε ys with s₁ ≤? s₂</a>
<a id="1661" class="Comment">-- pop′ s₂ a xs | until s₁ s₁≢ε ys | no s₁≰s₂ = xs .hd , fst (&lt;⇒≤ s₁≰s₂)</a>
<a id="1734" class="Comment">-- pop′ s₂ (acc wf) xs | until s₁ s₁≢ε ys | yes (k₁ , s₂≡s₁∙k₁) = pop′ k₁ (wf k₁ lemma) ys</a>
<a id="1825" class="Comment">--   where</a>
<a id="1836" class="Comment">--   lemma : k₁ &lt; s₂</a>
<a id="1857" class="Comment">--   lemma (k₂ , k₁≡s₂∙k₂) = s₁≢ε (zeroSumFree s₁ k₂ (sym (cancel k₁ _ _ p)))</a>
<a id="1935" class="Comment">--     where</a>
<a id="1948" class="Comment">--     p : k₁ ∙ ε ≡ k₁ ∙ (s₁ ∙ k₂)</a>
<a id="1983" class="Comment">--     p = ∙ε k₁ ; k₁≡s₂∙k₂ ; cong (_∙ k₂) s₂≡s₁∙k₁ ; cong (_∙ k₂) (comm s₁ k₁) ; assoc k₁ s₁ k₂</a>

<a id="2081" class="Comment">-- pop : Heap A → State A</a>
<a id="2107" class="Comment">-- pop xs s = pop′ s (wf s) xs</a>

<a id="2139" class="Comment">-- mutual</a>
<a id="2149" class="Comment">--   stepFrom : State A → (s : 𝑆) → Dec (s ≡ ε) → Span A</a>
<a id="2206" class="Comment">--   stepFrom f s (yes p) = []</a>
<a id="2237" class="Comment">--   stepFrom f s (no ¬p) = until s ¬p (tabulate (f ∘ (s ∙_)))</a>

<a id="2301" class="Comment">--   tabulate : State A → Heap A</a>
<a id="2334" class="Comment">--   tabulate f =</a>
<a id="2352" class="Comment">--     let x , s = f ε</a>
<a id="2375" class="Comment">--     in x ◃ λ where .next → stepFrom f s (s ≟ ε)</a>

<a id="2427" class="Comment">-- pop-ε : (xs : Heap A) (a : Acc _&lt;_ ε) → pop′ ε a xs .fst ≡ xs .hd</a>
<a id="2496" class="Comment">-- pop-ε xs _ with xs .tl .next</a>
<a id="2528" class="Comment">-- pop-ε xs _ | [] = refl</a>
<a id="2554" class="Comment">-- pop-ε xs _ | until s s≢ε ys with s ≤? ε</a>
<a id="2597" class="Comment">-- pop-ε xs _ | until s s≢ε ys | no  s≰ε = refl</a>
<a id="2645" class="Comment">-- pop-ε xs _ | until s s≢ε ys | yes s≤ε = ⊥-elim (s≢ε (antisym s≤ε (positive s)))</a>

<a id="2729" class="Comment">-- -- slide : Heap A → Heap A</a>
<a id="2759" class="Comment">-- -- slide xs with xs .tl .next</a>
<a id="2792" class="Comment">-- -- slide xs | [] = xs</a>
<a id="2817" class="Comment">-- -- slide xs | [] = []</a>

<a id="2843" class="Comment">-- -- pop-tl : ∀ (x : A) s₁ (s₁≢ε : s₁ ≢ ε) xs s₂ → pop (x ◃ ⟪ until s₁ s₁≢ε xs ⟫) (s₁ ∙ s₂) ≡ pop xs s₂</a>
<a id="2948" class="Comment">-- -- pop-tl x s₁ s₁≢ε xs s₂ with s₁ ≤? (s₁ ∙ s₂)</a>
<a id="2998" class="Comment">-- -- pop-tl x s₁ s₁≢ε xs s₂ | no  s₁≰s₁∙s₂ = ⊥-elim (s₁≰s₁∙s₂ (s₂ , refl))</a>
<a id="3074" class="Comment">-- -- pop-tl x s₁ s₁≢ε xs s₂ | yes (k , s₁≤s₁∙s₂) =</a>
<a id="3126" class="Comment">-- --   let p = cancel s₁ s₂ k s₁≤s₁∙s₂</a>
<a id="3166" class="Comment">-- --   in {!!} ; cong (λ w → pop′ s₂ w xs) (isPropAcc {!!} (wf s₂))</a>

<a id="3236" class="Comment">-- -- seg-leftInv′ : (x : Heap A) → tabulate (pop x) ≡ x</a>
<a id="3293" class="Comment">-- -- seg-leftInv′ x = {!!}</a>

<a id="3322" class="Comment">-- -- mutual</a>
<a id="3335" class="Comment">-- --   seg-leftInv′ : (xs : Heap A) → stepFrom (pop xs) (pop xs ε .snd) (pop xs ε .snd ≟ ε) ≡ xs .tl .next</a>
<a id="3443" class="Comment">-- --   seg-leftInv′ (x ◃ xs) with pop (x ◃ xs) ε .snd ≟ ε</a>
<a id="3502" class="Comment">-- --   seg-leftInv′ (x ◃ xs) | yes s≡ε = {!!}</a>
<a id="3549" class="Comment">-- --   seg-leftInv′ (x ◃ xs) | no  s≢ε = {!!}</a>

<a id="3597" class="Comment">-- --   seg-leftInv : (x : Heap A) → tabulate (pop x) ≡ x</a>
<a id="3655" class="Comment">-- --   seg-leftInv (x ◃ xs) i .hd = pop-ε (x ◃ xs) (wf ε) i</a>
<a id="3716" class="Comment">-- --   seg-leftInv (x ◃ xs) i .tl .next = seg-leftInv′ (x ◃ xs) i</a>

<a id="3784" class="Comment">-- -- state-iso : Heap A ⇔ State A</a>
<a id="3819" class="Comment">-- -- state-iso .fun = pop</a>
<a id="3846" class="Comment">-- -- state-iso .inv = tabulate</a>
<a id="3878" class="Comment">-- -- state-iso .rightInv = {!!}</a>
<a id="3911" class="Comment">-- -- state-iso .leftInv  = {!!}</a>
</pre></body></html>