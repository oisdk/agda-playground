<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Codata.Heap</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--allow-unsolved-metas</a> <a id="36" class="Symbol">#-}</a>

<a id="41" class="Keyword">open</a> <a id="46" class="Keyword">import</a> <a id="53" href="Prelude.html" class="Module">Prelude</a>
<a id="61" class="Keyword">open</a> <a id="66" class="Keyword">import</a> <a id="73" href="Algebra.html" class="Module">Algebra</a>
<a id="81" class="Keyword">open</a> <a id="86" class="Keyword">import</a> <a id="93" href="Algebra.Monus.html" class="Module">Algebra.Monus</a>

<a id="108" class="Keyword">module</a> <a id="115" href="Codata.Heap.html" class="Module">Codata.Heap</a>
  <a id="129" class="Symbol">{</a><a id="130" href="Codata.Heap.html#130" class="Bound">ℓ</a><a id="131" class="Symbol">}</a> <a id="133" class="Symbol">{</a><a id="134" href="Codata.Heap.html#134" class="Bound">𝑆</a> <a id="136" class="Symbol">:</a> <a id="138" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="143" href="Codata.Heap.html#130" class="Bound">ℓ</a><a id="144" class="Symbol">}</a>
  <a id="148" class="Symbol">(</a><a id="149" href="Codata.Heap.html#149" class="Bound">mon</a> <a id="153" class="Symbol">:</a> <a id="155" href="Algebra.Monus.html#11011" class="Record">CTMAPOM</a> <a id="163" href="Codata.Heap.html#134" class="Bound">𝑆</a><a id="164" class="Symbol">)</a>
  <a id="168" class="Keyword">where</a>

<a id="175" class="Keyword">open</a> <a id="180" href="Algebra.Monus.html#11011" class="Module">CTMAPOM</a> <a id="188" href="Codata.Heap.html#149" class="Bound">mon</a>

<a id="193" class="Keyword">open</a> <a id="198" class="Keyword">import</a> <a id="205" href="Data.List.html" class="Module">Data.List</a>

<a id="216" class="Keyword">private</a> <a id="224" class="Keyword">variable</a> <a id="233" href="Codata.Heap.html#233" class="Generalizable">i</a> <a id="235" href="Codata.Heap.html#235" class="Generalizable">j</a> <a id="237" class="Symbol">:</a> <a id="239" href="Codata.Heap.html#134" class="Bound">𝑆</a>

<a id="242" class="Keyword">data</a> <a id="Heap′"></a><a id="247" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="253" class="Symbol">{</a><a id="254" href="Codata.Heap.html#254" class="Bound">a</a><a id="255" class="Symbol">}</a> <a id="257" class="Symbol">(</a><a id="258" href="Codata.Heap.html#258" class="Bound">i</a> <a id="260" class="Symbol">:</a> <a id="262" href="Codata.Heap.html#134" class="Bound">𝑆</a><a id="263" class="Symbol">)</a> <a id="265" class="Symbol">(</a><a id="266" href="Codata.Heap.html#266" class="Bound">A</a> <a id="268" class="Symbol">:</a> <a id="270" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="275" href="Codata.Heap.html#254" class="Bound">a</a><a id="276" class="Symbol">)</a>  <a id="279" class="Symbol">:</a> <a id="281" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="286" class="Symbol">(</a><a id="287" href="Codata.Heap.html#254" class="Bound">a</a> <a id="289" href="Agda.Primitive.html#961" class="Primitive Operator">ℓ⊔</a> <a id="292" href="Codata.Heap.html#130" class="Bound">ℓ</a><a id="293" class="Symbol">)</a> <a id="295" class="Keyword">where</a>
  <a id="Heap′.heap"></a><a id="303" href="Codata.Heap.html#303" class="InductiveConstructor">heap</a> <a id="308" class="Symbol">:</a> <a id="310" href="Codata.Heap.html#266" class="Bound">A</a> <a id="312" class="Symbol">→</a> <a id="314" class="Symbol">∀</a> <a id="316" href="Codata.Heap.html#316" class="Bound">w</a> <a id="318" class="Symbol">→</a> <a id="320" class="Comment">-- Segment size</a>
          <a id="346" class="Symbol">(</a>  <a id="349" class="Symbol">(</a><a id="350" href="Codata.Heap.html#350" class="Bound">w&lt;i</a> <a id="354" class="Symbol">:</a> <a id="356" href="Codata.Heap.html#316" class="Bound">w</a> <a id="358" href="Relation.Binary.html#1921" class="Function Operator">&lt;</a> <a id="360" href="Codata.Heap.html#258" class="Bound">i</a><a id="361" class="Symbol">)</a> <a id="363" class="Symbol">→</a> 
             <a id="379" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="384" class="Symbol">(</a><a id="385" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="391" class="Symbol">(</a><a id="392" href="Codata.Heap.html#258" class="Bound">i</a> <a id="394" href="Algebra.Monus.html#5134" class="Function Operator">∸</a> <a id="396" href="Codata.Heap.html#316" class="Bound">w</a><a id="397" class="Symbol">)</a> <a id="399" href="Codata.Heap.html#266" class="Bound">A</a><a id="400" class="Symbol">)</a>
             <a id="415" class="Symbol">)</a> <a id="417" class="Symbol">→</a>
          <a id="429" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="435" href="Codata.Heap.html#258" class="Bound">i</a> <a id="437" href="Codata.Heap.html#266" class="Bound">A</a>

<a id="Heap"></a><a id="440" href="Codata.Heap.html#440" class="Function">Heap</a> <a id="445" class="Symbol">:</a> <a id="447" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="452" href="Level.html#266" class="Generalizable">a</a> <a id="454" class="Symbol">→</a> <a id="456" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="461" class="Symbol">(</a><a id="462" href="Level.html#266" class="Generalizable">a</a> <a id="464" href="Agda.Primitive.html#961" class="Primitive Operator">ℓ⊔</a> <a id="467" href="Codata.Heap.html#130" class="Bound">ℓ</a><a id="468" class="Symbol">)</a>
<a id="470" href="Codata.Heap.html#440" class="Function">Heap</a> <a id="475" href="Codata.Heap.html#475" class="Bound">A</a> <a id="477" class="Symbol">=</a> <a id="479" class="Symbol">∀</a> <a id="481" class="Symbol">{</a><a id="482" href="Codata.Heap.html#482" class="Bound">i</a><a id="483" class="Symbol">}</a> <a id="485" class="Symbol">→</a> <a id="487" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="493" href="Codata.Heap.html#482" class="Bound">i</a> <a id="495" href="Codata.Heap.html#475" class="Bound">A</a>

<a id="extract"></a><a id="498" href="Codata.Heap.html#498" class="Function">extract</a> <a id="506" class="Symbol">:</a> <a id="508" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="514" href="Codata.Heap.html#233" class="Generalizable">i</a> <a id="516" href="Level.html#282" class="Generalizable">A</a> <a id="518" class="Symbol">→</a> <a id="520" href="Level.html#282" class="Generalizable">A</a>
<a id="522" href="Codata.Heap.html#498" class="Function">extract</a> <a id="530" class="Symbol">(</a><a id="531" href="Codata.Heap.html#303" class="InductiveConstructor">heap</a> <a id="536" href="Codata.Heap.html#536" class="Bound">x</a> <a id="538" class="Symbol">_</a> <a id="540" class="Symbol">_)</a> <a id="543" class="Symbol">=</a> <a id="545" href="Codata.Heap.html#536" class="Bound">x</a>

<a id="duplicate"></a><a id="548" href="Codata.Heap.html#548" class="Function">duplicate</a> <a id="558" class="Symbol">:</a> <a id="560" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="566" class="Symbol">(</a><a id="567" href="Codata.Heap.html#233" class="Generalizable">i</a> <a id="569" href="Algebra.html#1413" class="Function Operator">∙</a> <a id="571" href="Codata.Heap.html#235" class="Generalizable">j</a><a id="572" class="Symbol">)</a> <a id="574" href="Level.html#282" class="Generalizable">A</a> <a id="576" class="Symbol">→</a> <a id="578" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="584" href="Codata.Heap.html#233" class="Generalizable">i</a> <a id="586" class="Symbol">(</a><a id="587" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="593" href="Codata.Heap.html#235" class="Generalizable">j</a> <a id="595" href="Level.html#282" class="Generalizable">A</a><a id="596" class="Symbol">)</a>
<a id="598" href="Codata.Heap.html#548" class="Function">duplicate</a> <a id="608" href="Codata.Heap.html#608" class="Bound">h</a><a id="609" class="Symbol">@(</a><a id="611" href="Codata.Heap.html#303" class="InductiveConstructor">heap</a> <a id="616" href="Codata.Heap.html#616" class="Bound">x</a> <a id="618" href="Codata.Heap.html#618" class="Bound">w</a> <a id="620" href="Codata.Heap.html#620" class="Bound">xs</a><a id="622" class="Symbol">)</a> <a id="624" class="Symbol">=</a> <a id="626" href="Codata.Heap.html#303" class="InductiveConstructor">heap</a> <a id="631" class="Hole">{!!}</a> <a id="636" href="Codata.Heap.html#618" class="Bound">w</a> <a id="638" class="Symbol">λ</a> <a id="640" href="Codata.Heap.html#640" class="Bound">p</a> <a id="642" class="Symbol">→</a> <a id="644" class="Keyword">let</a> <a id="648" href="Codata.Heap.html#648" class="Bound">q</a> <a id="650" class="Symbol">=</a> <a id="652" href="Data.List.Base.html#1144" class="Function">map</a> <a id="656" href="Codata.Heap.html#548" class="UnsolvedMeta Function">duplicate</a> <a id="666" class="Symbol">(</a><a id="667" href="Cubical.Foundations.Prelude.html#9156" class="Function">subst</a> <a id="673" class="Symbol">(</a><a id="674" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="679" href="Function.html#292" class="Function Operator">∘′</a> <a id="682" href="Function.html#369" class="Function">flip</a> <a id="687" href="Codata.Heap.html#247" class="Datatype">Heap′</a> <a id="693" class="Symbol">_)</a> <a id="696" class="Hole">{!!}</a> <a id="701" class="Symbol">(</a><a id="702" href="Codata.Heap.html#620" class="Bound">xs</a> <a id="705" class="Symbol">(</a><a id="706" class="Hole">{!!}</a><a id="710" class="Symbol">)))</a> <a id="714" class="Keyword">in</a> <a id="717" class="Hole">{!!}</a>

<a id="723" class="Comment">-- --------------------------------------------------------------------------------</a>
<a id="807" class="Comment">-- -- Empty colists</a>
<a id="827" class="Comment">-- --------------------------------------------------------------------------------</a>

<a id="912" class="Comment">-- -- To terminate computation you use all the fuel, making an empty list.</a>
<a id="987" class="Comment">-- -- (I&#39;m not sure how principled this is: semantically I don&#39;t know if I like</a>
<a id="1067" class="Comment">-- -- that the size of a segment can depend on the supplied size parameter).</a>
<a id="1144" class="Comment">-- empty : Heap A</a>
<a id="1162" class="Comment">-- empty {i = i} = i ◃ λ i&lt;i → ⊥-elim (irrefl i&lt;i)</a>

<a id="1214" class="Comment">-- -- --------------------------------------------------------------------------------</a>
<a id="1301" class="Comment">-- -- -- Finite derived colists</a>
<a id="1333" class="Comment">-- -- --------------------------------------------------------------------------------</a>

<a id="1421" class="Comment">-- -- -- singleton</a>
<a id="1440" class="Comment">-- -- pure : A → Heap A</a>
<a id="1464" class="Comment">-- -- pure x = x ∹ empty</a>

<a id="1490" class="Comment">-- -- replicate : ℕ → A → Heap A</a>
<a id="1523" class="Comment">-- -- replicate zero    x = empty</a>
<a id="1557" class="Comment">-- -- replicate (suc n) x = x ∹ replicate n x</a>

<a id="1604" class="Comment">-- -- --------------------------------------------------------------------------------</a>
<a id="1691" class="Comment">-- -- -- Infinite colists</a>
<a id="1717" class="Comment">-- -- --------------------------------------------------------------------------------</a>

<a id="1805" class="Comment">-- -- -- This unfold function produces an infinite list; it needs every size segment</a>
<a id="1890" class="Comment">-- -- -- be non empty so that each step uses some fuel. This is what provides the</a>
<a id="1972" class="Comment">-- -- -- termination argument.</a>

<a id="2004" class="Comment">-- -- module _</a>
<a id="2019" class="Comment">-- --     (B : 𝑆 → Type b) -- The seed type</a>
<a id="2063" class="Comment">-- --     (ϕ : ∀ {i} → -- At depth i</a>
<a id="2100" class="Comment">-- --            B i → -- With this seed</a>
<a id="2141" class="Comment">-- --            ∃ w × -- Produce a segment of size w</a>
<a id="2195" class="Comment">-- --            (w ≢ ε) × -- w can&#39;t be ε, so that we use some of the fuel to prove</a>
<a id="2280" class="Comment">-- --                      -- termination</a>
<a id="2322" class="Comment">-- --            ((w&lt;i : w &lt; i) → A × B (i ∸ w)) -- And produce the cons constructor.</a>
<a id="2408" class="Comment">-- --            )</a>
<a id="2427" class="Comment">-- --     -- ^ The step function</a>
<a id="2460" class="Comment">-- --     where</a>
<a id="2476" class="Comment">-- --     unfold′ : Acc _&lt;_ i → B i → Heap′ A i</a>
<a id="2524" class="Comment">-- --     unfold′ a = uncurry _◃_</a>
<a id="2558" class="Comment">-- --               ∘ map₂</a>
<a id="2585" class="Comment">-- --                 (λ { (w≢ε , xs′) w&lt;i →</a>
<a id="2630" class="Comment">-- --                        map₂ (case a of</a>
<a id="2675" class="Comment">-- --                               λ { (acc wf) →</a>
<a id="2726" class="Comment">-- --                                     unfold′ (wf _ (∸‿&lt;-&lt; _ _ w&lt;i w≢ε)) })</a>
<a id="2806" class="Comment">-- --                             (xs′ w&lt;i) })</a>
<a id="2853" class="Comment">-- --               ∘ ϕ</a>

<a id="2878" class="Comment">-- -- unfold : (fdc : WellFounded _&lt;_)</a>
<a id="2917" class="Comment">-- --          (B : 𝑆 → Type b)</a>
<a id="2949" class="Comment">-- --          (ϕ : ∀ {i} → B i → ∃ w × (w ≢ ε) × ((w&lt;i : w &lt; i) → A × B (i ∸ w))) →</a>
<a id="3034" class="Comment">-- --          (∀ {i} → B i) → Heap A</a>
<a id="3072" class="Comment">-- -- unfold fdc B ϕ xs {i} = unfold′ B ϕ (fdc i) xs</a>

<a id="3126" class="Comment">-- -- -- Here&#39;s a simple example using the unfold function: this produces infinitely</a>
<a id="3211" class="Comment">-- -- -- repeated values, with segment size s.</a>
<a id="3258" class="Comment">-- -- repeat : (fdc : WellFounded _&lt;_) (s : 𝑆) (s≢ε : s ≢ ε) (x : A) → Heap A</a>
<a id="3336" class="Comment">-- -- repeat fdc s s≢ε x = unfold fdc (const ⊤) (λ _ → s , s≢ε , const (x , tt)) tt</a>

<a id="3421" class="Comment">-- -- --------------------------------------------------------------------------------</a>
<a id="3508" class="Comment">-- -- -- Manipulating colists</a>
<a id="3538" class="Comment">-- -- --------------------------------------------------------------------------------</a>

<a id="3626" class="Comment">-- -- -- One important thing to note about the Heap type: it is inductive!</a>
<a id="3701" class="Comment">-- -- -- Although it does technically represent &quot;coinduction&quot;, the constructors and</a>
<a id="3785" class="Comment">-- -- -- type itself are inductive as far as Agda can see. For that reason functions</a>
<a id="3870" class="Comment">-- -- -- like map pass the termination checker with no extra ceremony.</a>
<a id="3941" class="Comment">-- -- map : (A → B) → Heap′ A i → Heap′ B i</a>
<a id="3985" class="Comment">-- -- map f (w ◃ xs) = w ◃ λ w&lt;i → case xs w&lt;i of λ { (y , ys) → f y , map f ys }</a>

<a id="4068" class="Comment">-- -- -- You can extract a finite prefix of the colist.</a>
<a id="4124" class="Comment">-- -- open import Data.List using (List; _∷_; [])</a>

<a id="4175" class="Comment">-- -- take′ : ∀ i → Heap′ A i → List A</a>
<a id="4214" class="Comment">-- -- take′ i (w ◃ xs) with w &lt;? i</a>
<a id="4249" class="Comment">-- -- ... | no _ = []</a>
<a id="4271" class="Comment">-- -- ... | yes w&lt;i with xs w&lt;i</a>
<a id="4303" class="Comment">-- -- ... | y , ys = y ∷ take′ _ ys</a>

<a id="4340" class="Comment">-- -- take : 𝑆 → Heap A → List A</a>
<a id="4373" class="Comment">-- -- take x xs = take′ x xs</a>
</pre></body></html>