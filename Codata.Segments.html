<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Codata.Segments</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">open</a> <a id="6" class="Keyword">import</a> <a id="13" href="Prelude.html" class="Module">Prelude</a>
<a id="21" class="Keyword">open</a> <a id="26" class="Keyword">import</a> <a id="33" href="Algebra.html" class="Module">Algebra</a>
<a id="41" class="Keyword">open</a> <a id="46" class="Keyword">import</a> <a id="53" href="Algebra.Monus.html" class="Module">Algebra.Monus</a>

<a id="68" class="Keyword">module</a> <a id="75" href="Codata.Segments.html" class="Module">Codata.Segments</a>
  <a id="93" class="Symbol">{</a><a id="94" href="Codata.Segments.html#94" class="Bound">ℓ</a><a id="95" class="Symbol">}</a> <a id="97" class="Symbol">{</a><a id="98" href="Codata.Segments.html#98" class="Bound">𝑆</a> <a id="100" class="Symbol">:</a> <a id="102" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="107" href="Codata.Segments.html#94" class="Bound">ℓ</a><a id="108" class="Symbol">}</a>
  <a id="112" class="Symbol">(</a><a id="113" href="Codata.Segments.html#113" class="Bound">mon</a> <a id="117" class="Symbol">:</a> <a id="119" href="Algebra.Monus.html#11011" class="Record">CTMAPOM</a> <a id="127" href="Codata.Segments.html#98" class="Bound">𝑆</a><a id="128" class="Symbol">)</a>
  <a id="132" class="Keyword">where</a>

<a id="139" class="Keyword">open</a> <a id="144" href="Algebra.Monus.html#11011" class="Module">CTMAPOM</a> <a id="152" href="Codata.Segments.html#113" class="Bound">mon</a>

<a id="157" class="Keyword">private</a> <a id="165" class="Keyword">variable</a> <a id="174" href="Codata.Segments.html#174" class="Generalizable">i</a> <a id="176" href="Codata.Segments.html#176" class="Generalizable">j</a> <a id="178" class="Symbol">:</a> <a id="180" href="Codata.Segments.html#98" class="Bound">𝑆</a>

<a id="183" class="Comment">-- This is a type which contains some finite and some infinite lists.</a>
<a id="253" class="Comment">-- The idea is that each entry contains a parameter (w) which says</a>
<a id="320" class="Comment">-- how much coinductive &quot;fuel&quot; it uses.</a>
<a id="360" class="Comment">-- The Colist′ A i type represents a colist which is defined down to depth</a>
<a id="435" class="Comment">-- i; the Colist A type represents a &quot;true&quot; colist, i.e. a colist defined for</a>
<a id="513" class="Comment">-- any given depth.</a>
<a id="533" class="Keyword">infixr</a> <a id="540" class="Number">5</a> <a id="542" href="Codata.Segments.html#608" class="InductiveConstructor Operator">_◃_</a>
<a id="546" class="Keyword">data</a> <a id="Colist′"></a><a id="551" href="Codata.Segments.html#551" class="Datatype">Colist′</a> <a id="559" class="Symbol">{</a><a id="560" href="Codata.Segments.html#560" class="Bound">a</a><a id="561" class="Symbol">}</a> <a id="563" class="Symbol">(</a><a id="564" href="Codata.Segments.html#564" class="Bound">A</a> <a id="566" class="Symbol">:</a> <a id="568" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="573" href="Codata.Segments.html#560" class="Bound">a</a><a id="574" class="Symbol">)</a> <a id="576" class="Symbol">(</a><a id="577" href="Codata.Segments.html#577" class="Bound">i</a> <a id="579" class="Symbol">:</a> <a id="581" href="Codata.Segments.html#98" class="Bound">𝑆</a><a id="582" class="Symbol">)</a> <a id="584" class="Symbol">:</a> <a id="586" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="591" class="Symbol">(</a><a id="592" href="Codata.Segments.html#560" class="Bound">a</a> <a id="594" href="Agda.Primitive.html#810" class="Primitive Operator">ℓ⊔</a> <a id="597" href="Codata.Segments.html#94" class="Bound">ℓ</a><a id="598" class="Symbol">)</a> <a id="600" class="Keyword">where</a>
  <a id="Colist′._◃_"></a><a id="608" href="Codata.Segments.html#608" class="InductiveConstructor Operator">_◃_</a> <a id="612" class="Symbol">:</a> <a id="614" class="Symbol">∀</a> <a id="616" href="Codata.Segments.html#616" class="Bound">w</a> <a id="618" class="Symbol">→</a> <a id="620" class="Comment">-- Segment size</a>
          <a id="646" class="Symbol">(</a>  <a id="649" class="Symbol">(</a><a id="650" href="Codata.Segments.html#650" class="Bound">w&lt;i</a> <a id="654" class="Symbol">:</a> <a id="656" href="Codata.Segments.html#616" class="Bound">w</a> <a id="658" href="Relation.Binary.html#1921" class="Function Operator">&lt;</a> <a id="660" href="Codata.Segments.html#577" class="Bound">i</a><a id="661" class="Symbol">)</a> <a id="663" class="Symbol">→</a> <a id="665" class="Comment">-- If there is enough fuel left (i is the fuel)</a>
                             <a id="742" class="Comment">-- (also the _&lt;_ type is a proposition)</a>
             <a id="795" href="Codata.Segments.html#564" class="Bound">A</a> <a id="797" href="Data.Sigma.Base.html#455" class="Function Operator">×</a> <a id="799" href="Codata.Segments.html#551" class="Datatype">Colist′</a> <a id="807" href="Codata.Segments.html#564" class="Bound">A</a> <a id="809" class="Symbol">(</a><a id="810" href="Codata.Segments.html#577" class="Bound">i</a> <a id="812" href="Algebra.Monus.html#5134" class="Function Operator">∸</a> <a id="814" href="Codata.Segments.html#616" class="Bound">w</a><a id="815" class="Symbol">)</a> <a id="817" class="Comment">-- Produce an element followed by the rest of</a>
                                   <a id="898" class="Comment">-- the list, with w taken out of the fuel.</a>
             <a id="954" class="Symbol">)</a> <a id="956" class="Symbol">→</a>
          <a id="968" href="Codata.Segments.html#551" class="Datatype">Colist′</a> <a id="976" href="Codata.Segments.html#564" class="Bound">A</a> <a id="978" href="Codata.Segments.html#577" class="Bound">i</a>

<a id="Colist"></a><a id="981" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="988" class="Symbol">:</a> <a id="990" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="995" href="Level.html#266" class="Generalizable">a</a> <a id="997" class="Symbol">→</a> <a id="999" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="1004" class="Symbol">(</a><a id="1005" href="Level.html#266" class="Generalizable">a</a> <a id="1007" href="Agda.Primitive.html#810" class="Primitive Operator">ℓ⊔</a> <a id="1010" href="Codata.Segments.html#94" class="Bound">ℓ</a><a id="1011" class="Symbol">)</a>
<a id="1013" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="1020" href="Codata.Segments.html#1020" class="Bound">A</a> <a id="1022" class="Symbol">=</a> <a id="1024" class="Symbol">∀</a> <a id="1026" class="Symbol">{</a><a id="1027" href="Codata.Segments.html#1027" class="Bound">i</a><a id="1028" class="Symbol">}</a> <a id="1030" class="Symbol">→</a> <a id="1032" href="Codata.Segments.html#551" class="Datatype">Colist′</a> <a id="1040" href="Codata.Segments.html#1020" class="Bound">A</a> <a id="1042" href="Codata.Segments.html#1027" class="Bound">i</a>

<a id="1045" class="Comment">-- The main interesting things tyhis type can do are the following:</a>
<a id="1113" class="Comment">-- * Infinite lists.</a>
<a id="1134" class="Comment">-- * The &quot;fuel&quot; parameter can be an arbitrary monoid, not just ℕ</a>
<a id="1199" class="Comment">-- * Finite lists can also be specified, and the way we say something is</a>
<a id="1272" class="Comment">--   finite is by taking no fuel.</a>
<a id="1306" class="Comment">-- * Everything seems to correspond correctly to the monus axioms.</a>

<a id="1374" class="Comment">--------------------------------------------------------------------------------</a>
<a id="1455" class="Comment">-- Finite colists</a>
<a id="1473" class="Comment">--------------------------------------------------------------------------------</a>

<a id="1555" class="Comment">-- By adding a finite prefix you don&#39;t have to use any of the fuel.</a>

<a id="_∹_"></a><a id="1624" href="Codata.Segments.html#1624" class="Function Operator">_∹_</a> <a id="1628" class="Symbol">:</a> <a id="1630" href="Level.html#282" class="Generalizable">A</a> <a id="1632" class="Symbol">→</a> <a id="1634" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="1641" href="Level.html#282" class="Generalizable">A</a> <a id="1643" class="Symbol">→</a> <a id="1645" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="1652" href="Level.html#282" class="Generalizable">A</a>
<a id="1654" href="Codata.Segments.html#1654" class="Bound">x</a> <a id="1656" href="Codata.Segments.html#1624" class="Function Operator">∹</a> <a id="1658" href="Codata.Segments.html#1658" class="Bound">xs</a> <a id="1661" class="Symbol">=</a> <a id="1663" href="Algebra.html#1438" class="Function">ε</a> <a id="1665" href="Codata.Segments.html#608" class="InductiveConstructor Operator">◃</a> <a id="1667" class="Symbol">λ</a> <a id="1669" href="Codata.Segments.html#1669" class="Bound">_</a> <a id="1671" class="Symbol">→</a> <a id="1673" href="Codata.Segments.html#1654" class="Bound">x</a> <a id="1675" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1677" href="Codata.Segments.html#1658" class="Bound">xs</a>

<a id="1681" class="Comment">--------------------------------------------------------------------------------</a>
<a id="1762" class="Comment">-- Empty colists</a>
<a id="1779" class="Comment">--------------------------------------------------------------------------------</a>

<a id="1861" class="Comment">-- To terminate computation you use all the fuel, making an empty list.</a>
<a id="1933" class="Comment">-- (I&#39;m not sure how principled this is: semantically I don&#39;t know if I like</a>
<a id="2010" class="Comment">-- that the size of a segment can depend on the supplied size parameter).</a>
<a id="empty"></a><a id="2084" href="Codata.Segments.html#2084" class="Function">empty</a> <a id="2090" class="Symbol">:</a> <a id="2092" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="2099" href="Level.html#282" class="Generalizable">A</a>
<a id="2101" href="Codata.Segments.html#2084" class="Function">empty</a> <a id="2107" class="Symbol">{</a><a id="2108" class="Argument">i</a> <a id="2110" class="Symbol">=</a> <a id="2112" href="Codata.Segments.html#2112" class="Bound">i</a><a id="2113" class="Symbol">}</a> <a id="2115" class="Symbol">=</a> <a id="2117" href="Codata.Segments.html#2112" class="Bound">i</a> <a id="2119" href="Codata.Segments.html#608" class="InductiveConstructor Operator">◃</a> <a id="2121" class="Symbol">λ</a> <a id="2123" href="Codata.Segments.html#2123" class="Bound">i&lt;i</a> <a id="2127" class="Symbol">→</a> <a id="2129" href="Data.Empty.Base.html#154" class="Function">⊥-elim</a> <a id="2136" class="Symbol">(</a><a id="2137" href="Relation.Binary.html#1974" class="Function">irrefl</a> <a id="2144" href="Codata.Segments.html#2123" class="Bound">i&lt;i</a><a id="2147" class="Symbol">)</a>

<a id="2150" class="Comment">--------------------------------------------------------------------------------</a>
<a id="2231" class="Comment">-- Finite derived colists</a>
<a id="2257" class="Comment">--------------------------------------------------------------------------------</a>

<a id="2339" class="Comment">-- singleton</a>
<a id="pure"></a><a id="2352" href="Codata.Segments.html#2352" class="Function">pure</a> <a id="2357" class="Symbol">:</a> <a id="2359" href="Level.html#282" class="Generalizable">A</a> <a id="2361" class="Symbol">→</a> <a id="2363" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="2370" href="Level.html#282" class="Generalizable">A</a>
<a id="2372" href="Codata.Segments.html#2352" class="Function">pure</a> <a id="2377" href="Codata.Segments.html#2377" class="Bound">x</a> <a id="2379" class="Symbol">=</a> <a id="2381" href="Codata.Segments.html#2377" class="Bound">x</a> <a id="2383" href="Codata.Segments.html#1624" class="Function Operator">∹</a> <a id="2385" href="Codata.Segments.html#2084" class="Function">empty</a>

<a id="replicate"></a><a id="2392" href="Codata.Segments.html#2392" class="Function">replicate</a> <a id="2402" class="Symbol">:</a> <a id="2404" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2406" class="Symbol">→</a> <a id="2408" href="Level.html#282" class="Generalizable">A</a> <a id="2410" class="Symbol">→</a> <a id="2412" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="2419" href="Level.html#282" class="Generalizable">A</a>
<a id="2421" href="Codata.Segments.html#2392" class="Function">replicate</a> <a id="2431" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2439" href="Codata.Segments.html#2439" class="Bound">x</a> <a id="2441" class="Symbol">=</a> <a id="2443" href="Codata.Segments.html#2084" class="Function">empty</a>
<a id="2449" href="Codata.Segments.html#2392" class="Function">replicate</a> <a id="2459" class="Symbol">(</a><a id="2460" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2464" href="Codata.Segments.html#2464" class="Bound">n</a><a id="2465" class="Symbol">)</a> <a id="2467" href="Codata.Segments.html#2467" class="Bound">x</a> <a id="2469" class="Symbol">=</a> <a id="2471" href="Codata.Segments.html#2467" class="Bound">x</a> <a id="2473" href="Codata.Segments.html#1624" class="Function Operator">∹</a> <a id="2475" href="Codata.Segments.html#2392" class="Function">replicate</a> <a id="2485" href="Codata.Segments.html#2464" class="Bound">n</a> <a id="2487" href="Codata.Segments.html#2467" class="Bound">x</a>

<a id="2490" class="Comment">--------------------------------------------------------------------------------</a>
<a id="2571" class="Comment">-- Infinite colists</a>
<a id="2591" class="Comment">--------------------------------------------------------------------------------</a>

<a id="2673" class="Comment">-- This unfold function produces an infinite list; it needs every size segment</a>
<a id="2752" class="Comment">-- be non empty so that each step uses some fuel. This is what provides the</a>
<a id="2828" class="Comment">-- termination argument.</a>

<a id="2854" class="Keyword">module</a> <a id="2861" href="Codata.Segments.html#2861" class="Module">_</a>
    <a id="2867" class="Symbol">(</a><a id="2868" href="Codata.Segments.html#2868" class="Bound">B</a> <a id="2870" class="Symbol">:</a> <a id="2872" href="Codata.Segments.html#98" class="Bound">𝑆</a> <a id="2874" class="Symbol">→</a> <a id="2876" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="2881" href="Level.html#268" class="Generalizable">b</a><a id="2882" class="Symbol">)</a> <a id="2884" class="Comment">-- The seed type</a>
    <a id="2905" class="Symbol">(</a><a id="2906" href="Codata.Segments.html#2906" class="Bound">ϕ</a> <a id="2908" class="Symbol">:</a> <a id="2910" class="Symbol">∀</a> <a id="2912" class="Symbol">{</a><a id="2913" href="Codata.Segments.html#2913" class="Bound">i</a><a id="2914" class="Symbol">}</a> <a id="2916" class="Symbol">→</a> <a id="2918" class="Comment">-- At depth i</a>
           <a id="2943" href="Codata.Segments.html#2868" class="Bound">B</a> <a id="2945" href="Codata.Segments.html#2913" class="Bound">i</a> <a id="2947" class="Symbol">→</a> <a id="2949" class="Comment">-- With this seed</a>
           <a id="2978" href="Data.Sigma.Base.html#173" class="Function">∃</a> <a id="2980" href="Codata.Segments.html#2980" class="Bound">w</a> <a id="2982" href="Data.Sigma.Base.html#173" class="Function">×</a> <a id="2984" class="Comment">-- Produce a segment of size w</a>
           <a id="3026" class="Symbol">(</a><a id="3027" href="Codata.Segments.html#2980" class="Bound">w</a> <a id="3029" href="Path.html#540" class="Function Operator">≢</a> <a id="3031" href="Algebra.html#1438" class="Function">ε</a><a id="3032" class="Symbol">)</a> <a id="3034" href="Data.Sigma.Base.html#455" class="Function Operator">×</a> <a id="3036" class="Comment">-- w can&#39;t be ε, so that we use some of the fuel to prove</a>
                     <a id="3115" class="Comment">-- termination</a>
           <a id="3141" class="Symbol">((</a><a id="3143" href="Codata.Segments.html#3143" class="Bound">w&lt;i</a> <a id="3147" class="Symbol">:</a> <a id="3149" href="Codata.Segments.html#2980" class="Bound">w</a> <a id="3151" href="Relation.Binary.html#1921" class="Function Operator">&lt;</a> <a id="3153" href="Codata.Segments.html#2913" class="Bound">i</a><a id="3154" class="Symbol">)</a> <a id="3156" class="Symbol">→</a> <a id="3158" href="Level.html#282" class="Generalizable">A</a> <a id="3160" href="Data.Sigma.Base.html#455" class="Function Operator">×</a> <a id="3162" href="Codata.Segments.html#2868" class="Bound">B</a> <a id="3164" class="Symbol">(</a><a id="3165" href="Codata.Segments.html#2913" class="Bound">i</a> <a id="3167" href="Algebra.Monus.html#5134" class="Function Operator">∸</a> <a id="3169" href="Codata.Segments.html#2980" class="Bound">w</a><a id="3170" class="Symbol">))</a> <a id="3173" class="Comment">-- And produce the cons constructor.</a>
           <a id="3221" class="Symbol">)</a>
    <a id="3227" class="Comment">-- ^ The step function</a>
    <a id="3254" class="Keyword">where</a>
    <a id="3264" href="Codata.Segments.html#3264" class="Function">unfold′</a> <a id="3272" class="Symbol">:</a> <a id="3274" href="WellFounded.html#85" class="Datatype">Acc</a> <a id="3278" href="Relation.Binary.html#1921" class="Function Operator">_&lt;_</a> <a id="3282" href="Codata.Segments.html#174" class="Generalizable">i</a> <a id="3284" class="Symbol">→</a> <a id="3286" href="Codata.Segments.html#2868" class="Bound">B</a> <a id="3288" href="Codata.Segments.html#174" class="Generalizable">i</a> <a id="3290" class="Symbol">→</a> <a id="3292" href="Codata.Segments.html#551" class="Datatype">Colist′</a> <a id="3300" href="Codata.Segments.html#3158" class="Bound">A</a> <a id="3302" href="Codata.Segments.html#174" class="Generalizable">i</a>
    <a id="3308" href="Codata.Segments.html#3264" class="Function">unfold′</a> <a id="3316" href="Codata.Segments.html#3316" class="Bound">a</a> <a id="3318" class="Symbol">=</a> <a id="3320" href="Data.Sigma.Base.html#711" class="Function">uncurry</a> <a id="3328" href="Codata.Segments.html#608" class="InductiveConstructor Operator">_◃_</a>
              <a id="3346" href="Function.html#97" class="Function Operator">∘</a> <a id="3348" href="Data.Sigma.Base.html#1314" class="Function">map₂</a>
                <a id="3369" class="Symbol">(λ</a> <a id="3372" class="Symbol">{</a> <a id="3374" class="Symbol">(</a><a id="3375" href="Codata.Segments.html#3375" class="Bound">w≢ε</a> <a id="3379" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3381" href="Codata.Segments.html#3381" class="Bound">xs′</a><a id="3384" class="Symbol">)</a> <a id="3386" href="Codata.Segments.html#3386" class="Bound">w&lt;i</a> <a id="3390" class="Symbol">→</a>
                       <a id="3415" href="Data.Sigma.Base.html#1314" class="Function">map₂</a> <a id="3420" class="Symbol">(</a><a id="3421" href="Function.html#1125" class="Function Operator">case</a> <a id="3426" href="Codata.Segments.html#3316" class="Bound">a</a> <a id="3428" href="Function.html#1125" class="Function Operator">of</a>
                              <a id="3461" class="Symbol">λ</a> <a id="3463" class="Symbol">{</a> <a id="3465" class="Symbol">(</a><a id="3466" href="WellFounded.html#161" class="InductiveConstructor">acc</a> <a id="3470" href="Codata.Segments.html#3470" class="Bound">wf</a><a id="3472" class="Symbol">)</a> <a id="3474" class="Symbol">→</a>
                                    <a id="3512" href="Codata.Segments.html#3264" class="Function">unfold′</a> <a id="3520" class="Symbol">(</a><a id="3521" href="Codata.Segments.html#3470" class="Bound">wf</a> <a id="3524" class="Symbol">_</a> <a id="3526" class="Symbol">(</a><a id="3527" href="Algebra.Monus.html#13951" class="Function">∸‿&lt;-&lt;</a> <a id="3533" class="Symbol">_</a> <a id="3535" class="Symbol">_</a> <a id="3537" href="Codata.Segments.html#3386" class="Bound">w&lt;i</a> <a id="3541" href="Codata.Segments.html#3375" class="Bound">w≢ε</a><a id="3544" class="Symbol">))</a> <a id="3547" class="Symbol">})</a>
                            <a id="3578" class="Symbol">(</a><a id="3579" href="Codata.Segments.html#3381" class="Bound">xs′</a> <a id="3583" href="Codata.Segments.html#3386" class="Bound">w&lt;i</a><a id="3586" class="Symbol">)</a> <a id="3588" class="Symbol">})</a>
              <a id="3605" href="Function.html#97" class="Function Operator">∘</a> <a id="3607" href="Codata.Segments.html#2906" class="Bound">ϕ</a>

<a id="unfold"></a><a id="3610" href="Codata.Segments.html#3610" class="Function">unfold</a> <a id="3617" class="Symbol">:</a> <a id="3619" class="Symbol">(</a><a id="3620" href="Codata.Segments.html#3620" class="Bound">fdc</a> <a id="3624" class="Symbol">:</a> <a id="3626" href="WellFounded.html#383" class="Function">WellFounded</a> <a id="3638" href="Relation.Binary.html#1921" class="Function Operator">_&lt;_</a><a id="3641" class="Symbol">)</a>
         <a id="3652" class="Symbol">(</a><a id="3653" href="Codata.Segments.html#3653" class="Bound">B</a> <a id="3655" class="Symbol">:</a> <a id="3657" href="Codata.Segments.html#98" class="Bound">𝑆</a> <a id="3659" class="Symbol">→</a> <a id="3661" href="Agda.Primitive.html#326" class="Primitive">Type</a> <a id="3666" href="Level.html#268" class="Generalizable">b</a><a id="3667" class="Symbol">)</a>
         <a id="3678" class="Symbol">(</a><a id="3679" href="Codata.Segments.html#3679" class="Bound">ϕ</a> <a id="3681" class="Symbol">:</a> <a id="3683" class="Symbol">∀</a> <a id="3685" class="Symbol">{</a><a id="3686" href="Codata.Segments.html#3686" class="Bound">i</a><a id="3687" class="Symbol">}</a> <a id="3689" class="Symbol">→</a> <a id="3691" href="Codata.Segments.html#3653" class="Bound">B</a> <a id="3693" href="Codata.Segments.html#3686" class="Bound">i</a> <a id="3695" class="Symbol">→</a> <a id="3697" href="Data.Sigma.Base.html#173" class="Function">∃</a> <a id="3699" href="Codata.Segments.html#3699" class="Bound">w</a> <a id="3701" href="Data.Sigma.Base.html#173" class="Function">×</a> <a id="3703" class="Symbol">(</a><a id="3704" href="Codata.Segments.html#3699" class="Bound">w</a> <a id="3706" href="Path.html#540" class="Function Operator">≢</a> <a id="3708" href="Algebra.html#1438" class="Function">ε</a><a id="3709" class="Symbol">)</a> <a id="3711" href="Data.Sigma.Base.html#455" class="Function Operator">×</a> <a id="3713" class="Symbol">((</a><a id="3715" href="Codata.Segments.html#3715" class="Bound">w&lt;i</a> <a id="3719" class="Symbol">:</a> <a id="3721" href="Codata.Segments.html#3699" class="Bound">w</a> <a id="3723" href="Relation.Binary.html#1921" class="Function Operator">&lt;</a> <a id="3725" href="Codata.Segments.html#3686" class="Bound">i</a><a id="3726" class="Symbol">)</a> <a id="3728" class="Symbol">→</a> <a id="3730" href="Level.html#282" class="Generalizable">A</a> <a id="3732" href="Data.Sigma.Base.html#455" class="Function Operator">×</a> <a id="3734" href="Codata.Segments.html#3653" class="Bound">B</a> <a id="3736" class="Symbol">(</a><a id="3737" href="Codata.Segments.html#3686" class="Bound">i</a> <a id="3739" href="Algebra.Monus.html#5134" class="Function Operator">∸</a> <a id="3741" href="Codata.Segments.html#3699" class="Bound">w</a><a id="3742" class="Symbol">)))</a> <a id="3746" class="Symbol">→</a>
         <a id="3757" class="Symbol">(∀</a> <a id="3760" class="Symbol">{</a><a id="3761" href="Codata.Segments.html#3761" class="Bound">i</a><a id="3762" class="Symbol">}</a> <a id="3764" class="Symbol">→</a> <a id="3766" href="Codata.Segments.html#3653" class="Bound">B</a> <a id="3768" href="Codata.Segments.html#3761" class="Bound">i</a><a id="3769" class="Symbol">)</a> <a id="3771" class="Symbol">→</a> <a id="3773" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="3780" href="Level.html#282" class="Generalizable">A</a>
<a id="3782" href="Codata.Segments.html#3610" class="Function">unfold</a> <a id="3789" href="Codata.Segments.html#3789" class="Bound">fdc</a> <a id="3793" href="Codata.Segments.html#3793" class="Bound">B</a> <a id="3795" href="Codata.Segments.html#3795" class="Bound">ϕ</a> <a id="3797" href="Codata.Segments.html#3797" class="Bound">xs</a> <a id="3800" class="Symbol">{</a><a id="3801" href="Codata.Segments.html#3801" class="Bound">i</a><a id="3802" class="Symbol">}</a> <a id="3804" class="Symbol">=</a> <a id="3806" href="Codata.Segments.html#3264" class="Function">unfold′</a> <a id="3814" href="Codata.Segments.html#3793" class="Bound">B</a> <a id="3816" href="Codata.Segments.html#3795" class="Bound">ϕ</a> <a id="3818" class="Symbol">(</a><a id="3819" href="Codata.Segments.html#3789" class="Bound">fdc</a> <a id="3823" href="Codata.Segments.html#3801" class="Bound">i</a><a id="3824" class="Symbol">)</a> <a id="3826" href="Codata.Segments.html#3797" class="Bound">xs</a>

<a id="3830" class="Comment">-- Here&#39;s a simple example using the unfold function: this produces infinitely</a>
<a id="3909" class="Comment">-- repeated values, with segment size s.</a>
<a id="repeat"></a><a id="3950" href="Codata.Segments.html#3950" class="Function">repeat</a> <a id="3957" class="Symbol">:</a> <a id="3959" class="Symbol">(</a><a id="3960" href="Codata.Segments.html#3960" class="Bound">fdc</a> <a id="3964" class="Symbol">:</a> <a id="3966" href="WellFounded.html#383" class="Function">WellFounded</a> <a id="3978" href="Relation.Binary.html#1921" class="Function Operator">_&lt;_</a><a id="3981" class="Symbol">)</a> <a id="3983" class="Symbol">(</a><a id="3984" href="Codata.Segments.html#3984" class="Bound">s</a> <a id="3986" class="Symbol">:</a> <a id="3988" href="Codata.Segments.html#98" class="Bound">𝑆</a><a id="3989" class="Symbol">)</a> <a id="3991" class="Symbol">(</a><a id="3992" href="Codata.Segments.html#3992" class="Bound">s≢ε</a> <a id="3996" class="Symbol">:</a> <a id="3998" href="Codata.Segments.html#3984" class="Bound">s</a> <a id="4000" href="Path.html#540" class="Function Operator">≢</a> <a id="4002" href="Algebra.html#1438" class="Function">ε</a><a id="4003" class="Symbol">)</a> <a id="4005" class="Symbol">(</a><a id="4006" href="Codata.Segments.html#4006" class="Bound">x</a> <a id="4008" class="Symbol">:</a> <a id="4010" href="Level.html#282" class="Generalizable">A</a><a id="4011" class="Symbol">)</a> <a id="4013" class="Symbol">→</a> <a id="4015" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="4022" href="Level.html#282" class="Generalizable">A</a>
<a id="4024" href="Codata.Segments.html#3950" class="Function">repeat</a> <a id="4031" href="Codata.Segments.html#4031" class="Bound">fdc</a> <a id="4035" href="Codata.Segments.html#4035" class="Bound">s</a> <a id="4037" href="Codata.Segments.html#4037" class="Bound">s≢ε</a> <a id="4041" href="Codata.Segments.html#4041" class="Bound">x</a> <a id="4043" class="Symbol">=</a> <a id="4045" href="Codata.Segments.html#3610" class="Function">unfold</a> <a id="4052" href="Codata.Segments.html#4031" class="Bound">fdc</a> <a id="4056" class="Symbol">(</a><a id="4057" href="Function.html#589" class="Function">const</a> <a id="4063" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="4064" class="Symbol">)</a> <a id="4066" class="Symbol">(λ</a> <a id="4069" href="Codata.Segments.html#4069" class="Bound">_</a> <a id="4071" class="Symbol">→</a> <a id="4073" href="Codata.Segments.html#4035" class="Bound">s</a> <a id="4075" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4077" href="Codata.Segments.html#4037" class="Bound">s≢ε</a> <a id="4081" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4083" href="Function.html#589" class="Function">const</a> <a id="4089" class="Symbol">(</a><a id="4090" href="Codata.Segments.html#4041" class="Bound">x</a> <a id="4092" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4094" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="4096" class="Symbol">))</a> <a id="4099" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>

<a id="4103" class="Comment">--------------------------------------------------------------------------------</a>
<a id="4184" class="Comment">-- Manipulating colists</a>
<a id="4208" class="Comment">--------------------------------------------------------------------------------</a>

<a id="4290" class="Comment">-- One important thing to note about the Colist type: it is inductive!</a>
<a id="4361" class="Comment">-- Although it does technically represent &quot;coinduction&quot;, the constructors and</a>
<a id="4439" class="Comment">-- type itself are inductive as far as Agda can see. For that reason functions</a>
<a id="4518" class="Comment">-- like map pass the termination checker with no extra ceremony.</a>
<a id="map"></a><a id="4583" href="Codata.Segments.html#4583" class="Function">map</a> <a id="4587" class="Symbol">:</a> <a id="4589" class="Symbol">(</a><a id="4590" href="Level.html#282" class="Generalizable">A</a> <a id="4592" class="Symbol">→</a> <a id="4594" href="Level.html#296" class="Generalizable">B</a><a id="4595" class="Symbol">)</a> <a id="4597" class="Symbol">→</a> <a id="4599" href="Codata.Segments.html#551" class="Datatype">Colist′</a> <a id="4607" href="Level.html#282" class="Generalizable">A</a> <a id="4609" href="Codata.Segments.html#174" class="Generalizable">i</a> <a id="4611" class="Symbol">→</a> <a id="4613" href="Codata.Segments.html#551" class="Datatype">Colist′</a> <a id="4621" href="Level.html#296" class="Generalizable">B</a> <a id="4623" href="Codata.Segments.html#174" class="Generalizable">i</a>
<a id="4625" href="Codata.Segments.html#4583" class="Function">map</a> <a id="4629" href="Codata.Segments.html#4629" class="Bound">f</a> <a id="4631" class="Symbol">(</a><a id="4632" href="Codata.Segments.html#4632" class="Bound">w</a> <a id="4634" href="Codata.Segments.html#608" class="InductiveConstructor Operator">◃</a> <a id="4636" href="Codata.Segments.html#4636" class="Bound">xs</a><a id="4638" class="Symbol">)</a> <a id="4640" class="Symbol">=</a> <a id="4642" href="Codata.Segments.html#4632" class="Bound">w</a> <a id="4644" href="Codata.Segments.html#608" class="InductiveConstructor Operator">◃</a> <a id="4646" class="Symbol">λ</a> <a id="4648" href="Codata.Segments.html#4648" class="Bound">w&lt;i</a> <a id="4652" class="Symbol">→</a> <a id="4654" href="Function.html#1125" class="Function Operator">case</a> <a id="4659" href="Codata.Segments.html#4636" class="Bound">xs</a> <a id="4662" href="Codata.Segments.html#4648" class="Bound">w&lt;i</a> <a id="4666" href="Function.html#1125" class="Function Operator">of</a> <a id="4669" class="Symbol">λ</a> <a id="4671" class="Symbol">{</a> <a id="4673" class="Symbol">(</a><a id="4674" href="Codata.Segments.html#4674" class="Bound">y</a> <a id="4676" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4678" href="Codata.Segments.html#4678" class="Bound">ys</a><a id="4680" class="Symbol">)</a> <a id="4682" class="Symbol">→</a> <a id="4684" href="Codata.Segments.html#4629" class="Bound">f</a> <a id="4686" href="Codata.Segments.html#4674" class="Bound">y</a> <a id="4688" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4690" href="Codata.Segments.html#4583" class="Function">map</a> <a id="4694" href="Codata.Segments.html#4629" class="Bound">f</a> <a id="4696" href="Codata.Segments.html#4678" class="Bound">ys</a> <a id="4699" class="Symbol">}</a>

<a id="4702" class="Comment">-- You can extract a finite prefix of the colist.</a>
<a id="4752" class="Keyword">open</a> <a id="4757" class="Keyword">import</a> <a id="4764" href="Data.List.html" class="Module">Data.List</a> <a id="4774" class="Keyword">using</a> <a id="4780" class="Symbol">(</a><a id="4781" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="4785" class="Symbol">;</a> <a id="4787" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="4790" class="Symbol">;</a> <a id="4792" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4794" class="Symbol">)</a>

<a id="take′"></a><a id="4797" href="Codata.Segments.html#4797" class="Function">take′</a> <a id="4803" class="Symbol">:</a> <a id="4805" class="Symbol">∀</a> <a id="4807" href="Codata.Segments.html#4807" class="Bound">i</a> <a id="4809" class="Symbol">→</a> <a id="4811" href="Codata.Segments.html#551" class="Datatype">Colist′</a> <a id="4819" href="Level.html#282" class="Generalizable">A</a> <a id="4821" href="Codata.Segments.html#4807" class="Bound">i</a> <a id="4823" class="Symbol">→</a> <a id="4825" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4830" href="Level.html#282" class="Generalizable">A</a>
<a id="4832" href="Codata.Segments.html#4797" class="Function">take′</a> <a id="4838" href="Codata.Segments.html#4838" class="Bound">i</a> <a id="4840" class="Symbol">(</a><a id="4841" href="Codata.Segments.html#4841" class="Bound">w</a> <a id="4843" href="Codata.Segments.html#608" class="InductiveConstructor Operator">◃</a> <a id="4845" href="Codata.Segments.html#4845" class="Bound">xs</a><a id="4847" class="Symbol">)</a> <a id="4849" class="Keyword">with</a> <a id="4854" href="Codata.Segments.html#4841" class="Bound">w</a> <a id="4856" href="Relation.Binary.html#3061" class="Function Operator">&lt;?</a> <a id="4859" href="Codata.Segments.html#4838" class="Bound">i</a>
<a id="4861" class="Symbol">...</a> <a id="4865" class="Symbol">|</a> <a id="4867" href="Relation.Nullary.Decidable.html#433" class="InductiveConstructor">no</a> <a id="4870" class="Symbol">_</a> <a id="4872" class="Symbol">=</a> <a id="4874" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
<a id="4877" class="Symbol">...</a> <a id="4881" class="Symbol">|</a> <a id="4883" href="Relation.Nullary.Decidable.html#399" class="InductiveConstructor">yes</a> <a id="4887" href="Codata.Segments.html#4887" class="Bound">w&lt;i</a> <a id="4891" class="Keyword">with</a> <a id="4896" class="Bound">xs</a> <a id="4899" href="Codata.Segments.html#4887" class="Bound">w&lt;i</a>
<a id="4903" class="Symbol">...</a> <a id="4907" class="Symbol">|</a> <a id="4909" href="Codata.Segments.html#4909" class="Bound">y</a> <a id="4911" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4913" href="Codata.Segments.html#4913" class="Bound">ys</a> <a id="4916" class="Symbol">=</a> <a id="4918" href="Codata.Segments.html#4909" class="Bound">y</a> <a id="4920" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4922" href="Codata.Segments.html#4797" class="Function">take′</a> <a id="4928" class="Symbol">_</a> <a id="4930" href="Codata.Segments.html#4913" class="Bound">ys</a>

<a id="take"></a><a id="4934" href="Codata.Segments.html#4934" class="Function">take</a> <a id="4939" class="Symbol">:</a> <a id="4941" href="Codata.Segments.html#98" class="Bound">𝑆</a> <a id="4943" class="Symbol">→</a> <a id="4945" href="Codata.Segments.html#981" class="Function">Colist</a> <a id="4952" href="Level.html#282" class="Generalizable">A</a> <a id="4954" class="Symbol">→</a> <a id="4956" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4961" href="Level.html#282" class="Generalizable">A</a>
<a id="4963" href="Codata.Segments.html#4934" class="Function">take</a> <a id="4968" href="Codata.Segments.html#4968" class="Bound">x</a> <a id="4970" href="Codata.Segments.html#4970" class="Bound">xs</a> <a id="4973" class="Symbol">=</a> <a id="4975" href="Codata.Segments.html#4797" class="Function">take′</a> <a id="4981" href="Codata.Segments.html#4968" class="Bound">x</a> <a id="4983" href="Codata.Segments.html#4970" class="Bound">xs</a>
</pre></body></html>